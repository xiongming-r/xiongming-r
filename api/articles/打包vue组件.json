{"title":"打包vue组件为依赖(踩坑记录)","uid":"e8914152cbd2f8ddb44af0ed03340963","slug":"打包vue组件","date":"2023-11-01T08:42:32.815Z","updated":"2023-11-01T10:07:21.205Z","comments":true,"path":"api/articles/打包vue组件.json","keywords":null,"cover":[],"content":"<p>这篇主要是记录一下将vue的一个组件,打包成可以npm安装的依赖的过程中,遇到的问题和一些理解</p>\n<p>背景: 有这个想法是因为有一个对比admin管理系统来说非常常见的一个组件(搜索+表格的组件),希望能打包成依赖在不同的项目中方便随时引用而不是复制代码</p>\n<p>组件内部实现逻辑先不论</p>\n<p>使用的是vite打包</p>\n<p>关键1:vite的build配置项:<img src=\"C:\\Users\\44684\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231101172959624.png\" alt=\"image-20231101172959624\"></p>\n<p>我的配置:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">build: &#123;\n      lib: &#123;\n        entry: &quot;src&#x2F;index.ts&quot;,\n        name: &quot;ProTable&quot;,\n      &#125;,\n      rollupOptions: &#123;\n        external: [&#39;vue&#39;],\n        output: &#123;\n          globals: &#123;\n            vue: &quot;Vue&quot;\n          &#125;\n        &#125;\n      &#125;\n    &#125;,</code></pre>\n\n<p>官方示例:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; vite.config.js\nimport &#123; resolve &#125; from &#39;path&#39;\nimport &#123; defineConfig &#125; from &#39;vite&#39;\n\nexport default defineConfig(&#123;\n  build: &#123;\n    lib: &#123;\n      &#x2F;&#x2F; Could also be a dictionary or array of multiple entry points\n      entry: resolve(__dirname, &#39;lib&#x2F;main.js&#39;),\n      name: &#39;MyLib&#39;,\n      &#x2F;&#x2F; the proper extensions will be added\n      fileName: &#39;my-lib&#39;,\n    &#125;,\n    rollupOptions: &#123;\n      &#x2F;&#x2F; 确保外部化处理那些你不想打包进库的依赖\n      external: [&#39;vue&#39;],\n      output: &#123;\n        &#x2F;&#x2F; 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量\n        globals: &#123;\n          vue: &#39;Vue&#39;,\n        &#125;,\n      &#125;,\n    &#125;,\n  &#125;,\n&#125;)\n</code></pre>\n\n\n\n<p>关键点2:入口文件做导入导出</p>\n<p>官方示例:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; lib&#x2F;main.js\nimport Foo from &#39;.&#x2F;Foo.vue&#39;\nimport Bar from &#39;.&#x2F;Bar.vue&#39;\nexport &#123; Foo, Bar &#125;\n</code></pre>\n\n<p>我的配置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import ProTable from &quot;.&#x2F;installComponents&quot;;\n&#x2F;&#x2F; import Vue from &#39;vue&#39;\n&#x2F;&#x2F; element css\nimport &quot;element-plus&#x2F;dist&#x2F;index.css&quot;;\n&#x2F;&#x2F; element dark css\nimport &quot;element-plus&#x2F;theme-chalk&#x2F;dark&#x2F;css-vars.css&quot;;\n&#x2F;&#x2F; custom element dark css\nimport &quot;@&#x2F;styles&#x2F;element-dark.scss&quot;;\n&#x2F;&#x2F; custom element css\nimport &quot;@&#x2F;styles&#x2F;element.scss&quot;;\n\n&#x2F;&#x2F; 以数组的结构保存组件，便于遍历\nconst components &#x3D; [\n    ProTable\n]\nexport &#123; ProTable &#125;\n\n&#x2F;&#x2F; 定义 install 方法\nconst install &#x3D; function (Vue: any) &#123;\n    if (install.installed) return\n    install.installed &#x3D; true\n    &#x2F;&#x2F; 遍历并注册全局组件\n    components.map(component &#x3D;&gt; &#123;\n        console.log(&quot;omponent.name&#x3D;&#x3D;&#x3D;&quot;, component.name);\n\n        Vue.component(component.name, component)\n    &#125;)\n&#125;\n\nif (typeof window !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; window.Vue) &#123;\n    install(window.Vue)\n&#125;\n\nexport default &#123;\n    &#x2F;&#x2F; 导出的对象必须具备一个 install 方法\n    install,\n    ...components\n&#125;</code></pre>\n\n<p>我的配置中定义了install 方法,因为挂载到新项目中时,支持app.use()方式调用,需要对象有一个install方法,use的时候会自动调用install方法将组件进行挂载, 同时页面中用到的全局样式,在这里也可以导入</p>\n<p>关键点3:package.json配置</p>\n<p>官方示例:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#123;\n  &quot;name&quot;: &quot;my-lib&quot;,\n  &quot;type&quot;: &quot;module&quot;,\n  &quot;files&quot;: [&quot;dist&quot;],\n  &quot;main&quot;: &quot;.&#x2F;dist&#x2F;my-lib.umd.cjs&quot;,\n  &quot;module&quot;: &quot;.&#x2F;dist&#x2F;my-lib.js&quot;,\n  &quot;exports&quot;: &#123;\n    &quot;.&quot;: &#123;\n      &quot;import&quot;: &quot;.&#x2F;dist&#x2F;my-lib.js&quot;,\n      &quot;require&quot;: &quot;.&#x2F;dist&#x2F;my-lib.umd.cjs&quot;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n\n<p>我的配置:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&quot;name&quot;: &quot;protable&quot;,\n&quot;version&quot;: &quot;0.0.9&quot;,\n&quot;type&quot;: &quot;module&quot;,\n&quot;main&quot;: &quot;dist&#x2F;protable.umd.cjs&quot;,\n&quot;module&quot;: &quot;dist&#x2F;protable.js&quot;,\n&quot;files&quot;: [\n  &quot;dist&#x2F;*&quot;\n],\n&quot;license&quot;: &quot;MIT&quot;,</code></pre>\n\n\n\n<p>后面的打包流程就比较统一, npm build + npm login+ npm publish</p>\n","feature":true,"text":"这篇主要是记录一下将vue的一个组件,打包成可以npm安装的依赖的过程中,遇到的问题和一些理解 背景: 有这个想法是因为有一个对比admin管理系统来说非常常见的一个组件(搜索+表格的组件),希望能打包成依赖在不同的项目中方便随时引用而不是复制代码 组件内部实现逻辑先不论 使用的...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"vue","slug":"vue","count":1,"path":"api/categories/vue.json"}],"tags":[{"name":"vue","slug":"vue","count":1,"path":"api/tags/vue.json"}],"toc":"","author":{"name":"xm","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"动态配置文件问题","uid":"e37b5468da7c2bd7ab9ce67d0133d9cb","slug":"动态配置文件问题","date":"2023-11-09T04:02:56.763Z","updated":"2023-12-06T08:40:14.137Z","comments":true,"path":"api/articles/动态配置文件问题.json","keywords":null,"cover":null,"text":"记录一下遇到的一个奇怪的场景需求,因为各种原因,需要让前端项目在build之后,还能动态配置请求的后端接口地址,走的是docker镜像那一套,这个场景很蛋疼,build之后的vue项目,是一个静态包,设置好的环境变量也是在构建时设置好的, 也就是如果不走构建的步骤,无法保证动态,...","link":"","photos":[],"count_time":{"symbolsCount":358,"symbolsTime":"1 mins."},"categories":[{"name":"疑难杂症","slug":"疑难杂症","count":1,"path":"api/categories/疑难杂症.json"}],"tags":[{"name":"疑难杂症","slug":"疑难杂症","count":1,"path":"api/tags/疑难杂症.json"}],"author":{"name":"xm","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Frist Blog","uid":"e1121624ccf7ee8269e7ec667bade830","slug":"frist-blog","date":"2023-08-08T06:45:34.829Z","updated":"2023-08-09T06:12:52.368Z","comments":true,"path":"api/articles/frist-blog.json","keywords":null,"cover":null,"text":"前端小憩站：起航的第一步代码的魔法舞台嗨，各位码农和前端爱好者！欢迎来到前端小憩站，这是我人生中的第一篇博客，希望和大家一起探索前端开发的无限魅力！ 揭开技术面纱稍等一下，别走开！其实，我在写代码之余还是一个游戏爱好者。我相信，这种多样化的兴趣能够为我的前端旅程增添更多色彩。 前...","link":"","photos":[],"count_time":{"symbolsCount":564,"symbolsTime":"1 mins."},"categories":[{"name":"随笔","slug":"随笔","count":1,"path":"api/categories/随笔.json"}],"tags":[{"name":"随笔","slug":"随笔","count":1,"path":"api/tags/随笔.json"}],"author":{"name":"xm","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}