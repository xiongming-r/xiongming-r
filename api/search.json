[{"id":"3f61c0bdcd846206aa0219d8f28ee513","title":"试试搞一个脚手架(瞎玩)","content":"实现一个类似 Vue-CLI 的 Node 脚手架单纯想尝试一下实现类似 Vue-CLI 的脚手架，这实际上更像一个脚本。\n设想想要创建一个可以全局安装并使用的工具，类似于 vue-cli。这个工具应该能与命令行交互，让用户选择自己想要的模板，然后生成相应的项目。\n实现步骤第一步：了解 Node 相关工具由于擅长 JavaScript，决定使用 Node.js 来完成这个工具。首先，需要了解以下工具：\n\nInquirer.js: 用于创建交互式命令行用户界面。\ndownload-git-repo: 用来下载或克隆模板项目。\nrimraf: 用来删除 .git 记录等。\nchalk 和 figlet: 用来展示欢迎语。\nora: 用于显示进度。\nfs: 处理文件系统相关操作。\n\n第二步：初始化项目并编写代码\n初始化一个 Node.js 项目并安装依赖：\n mkdir my-scaffolding-tool\ncd my-scaffolding-tool\nnpm init -y\nnpm install inquirer ...\n\n编写脚手架代码：\n 2.1 初始化 bin/index.js，引入相关库，定义一个 init 函数，并主动调用它。首先写一个简单的欢迎语和一个交互函数。\n #!&#x2F;usr&#x2F;bin&#x2F;env node\nimport inquirer from &#39;inquirer&#39;\nimport download from &#39;download-git-repo&#39;;\nimport chalk from &#39;chalk&#39;\nimport figlet from &#39;figlet&#39;;\nimport ora from &#39;ora&#39;\nimport path from &#39;path&#39;\nimport fs from &#39;fs&#39;\nimport &#123; sync as rimraf &#125; from &#39;rimraf&#39;;\n\nasync function init()&#123;\n    console.log(chalk.yellow(figlet.textSync(&#39;super-cli&#39;, &#123; horizontalLayout: &#39;full&#39; &#125;)));\n    const answers &#x3D; await inquirer.prompt([...])\n&#125;\n\ninit()\n\n   \n 2.2 读取运行时目录，下载模板文件。这里模板文件地址是固定的。\n &#x2F;&#x2F; ... 前面的代码\n\ntry &#123;\n    &#x2F;&#x2F; 模板下载逻辑\n&#125; catch (error) &#123;\n    &#x2F;&#x2F; 错误处理\n&#125;\n\n   \n 貌似一切正常。\n 2.3 定义一些操作项目的函数。具体的代码实现这里就不展示了。对这个玩具项目感兴趣的小伙伴可以在 GitHub 上查看和尝试。\n GitHub 仓库链接\n\n\n","slug":"试试搞一个脚手架(瞎玩)","date":"2023-12-06T06:52:25.020Z","categories_index":"node","tags_index":"node","author_index":"xm"},{"id":"e37b5468da7c2bd7ab9ce67d0133d9cb","title":"动态配置文件问题","content":"记录一下遇到的一个奇怪的场景需求,因为各种原因,需要让前端项目在build之后,还能动态配置请求的后端接口地址,走的是docker镜像那一套,这个场景很蛋疼,build之后的vue项目,是一个静态包,设置好的环境变量也是在构建时设置好的, 也就是如果不走构建的步骤,无法保证动态,所以尝试了一下方法1.定义一个config类的文件,到public, 打包的时候配置到根目录,里面写好配置项,然后静态引入到index.html,把变量注入到Window或其他对象上,然后docker run 的时候去覆盖掉这个文件(写一个sh脚本)2.定义文件如上,只是把docker处理的步骤,换成写一个前端服务(node)去读取 docker run -e去定义环境变量,node去读取,然后修改config类文件,其余步骤一样\n","slug":"动态配置文件问题","date":"2023-11-09T04:02:56.763Z","categories_index":"疑难杂症","tags_index":"疑难杂症","author_index":"xm"},{"id":"e8914152cbd2f8ddb44af0ed03340963","title":"打包vue组件为依赖(踩坑记录)","content":"这篇主要是记录一下将vue的一个组件,打包成可以npm安装的依赖的过程中,遇到的问题和一些理解\n背景: 有这个想法是因为有一个对比admin管理系统来说非常常见的一个组件(搜索+表格的组件),希望能打包成依赖在不同的项目中方便随时引用而不是复制代码\n组件内部实现逻辑先不论\n使用的是vite打包\n关键1:vite的build配置项:\n我的配置:\nbuild: &#123;\n      lib: &#123;\n        entry: &quot;src&#x2F;index.ts&quot;,\n        name: &quot;ProTable&quot;,\n      &#125;,\n      rollupOptions: &#123;\n        external: [&#39;vue&#39;],\n        output: &#123;\n          globals: &#123;\n            vue: &quot;Vue&quot;\n          &#125;\n        &#125;\n      &#125;\n    &#125;,\n\n官方示例:\n&#x2F;&#x2F; vite.config.js\nimport &#123; resolve &#125; from &#39;path&#39;\nimport &#123; defineConfig &#125; from &#39;vite&#39;\n\nexport default defineConfig(&#123;\n  build: &#123;\n    lib: &#123;\n      &#x2F;&#x2F; Could also be a dictionary or array of multiple entry points\n      entry: resolve(__dirname, &#39;lib&#x2F;main.js&#39;),\n      name: &#39;MyLib&#39;,\n      &#x2F;&#x2F; the proper extensions will be added\n      fileName: &#39;my-lib&#39;,\n    &#125;,\n    rollupOptions: &#123;\n      &#x2F;&#x2F; 确保外部化处理那些你不想打包进库的依赖\n      external: [&#39;vue&#39;],\n      output: &#123;\n        &#x2F;&#x2F; 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量\n        globals: &#123;\n          vue: &#39;Vue&#39;,\n        &#125;,\n      &#125;,\n    &#125;,\n  &#125;,\n&#125;)\n\n\n\n\n关键点2:入口文件做导入导出\n官方示例:\n&#x2F;&#x2F; lib&#x2F;main.js\nimport Foo from &#39;.&#x2F;Foo.vue&#39;\nimport Bar from &#39;.&#x2F;Bar.vue&#39;\nexport &#123; Foo, Bar &#125;\n\n\n我的配置\nimport ProTable from &quot;.&#x2F;installComponents&quot;;\n&#x2F;&#x2F; import Vue from &#39;vue&#39;\n&#x2F;&#x2F; element css\nimport &quot;element-plus&#x2F;dist&#x2F;index.css&quot;;\n&#x2F;&#x2F; element dark css\nimport &quot;element-plus&#x2F;theme-chalk&#x2F;dark&#x2F;css-vars.css&quot;;\n&#x2F;&#x2F; custom element dark css\nimport &quot;@&#x2F;styles&#x2F;element-dark.scss&quot;;\n&#x2F;&#x2F; custom element css\nimport &quot;@&#x2F;styles&#x2F;element.scss&quot;;\n\n&#x2F;&#x2F; 以数组的结构保存组件，便于遍历\nconst components &#x3D; [\n    ProTable\n]\nexport &#123; ProTable &#125;\n\n&#x2F;&#x2F; 定义 install 方法\nconst install &#x3D; function (Vue: any) &#123;\n    if (install.installed) return\n    install.installed &#x3D; true\n    &#x2F;&#x2F; 遍历并注册全局组件\n    components.map(component &#x3D;&gt; &#123;\n        console.log(&quot;omponent.name&#x3D;&#x3D;&#x3D;&quot;, component.name);\n\n        Vue.component(component.name, component)\n    &#125;)\n&#125;\n\nif (typeof window !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; window.Vue) &#123;\n    install(window.Vue)\n&#125;\n\nexport default &#123;\n    &#x2F;&#x2F; 导出的对象必须具备一个 install 方法\n    install,\n    ...components\n&#125;\n\n我的配置中定义了install 方法,因为挂载到新项目中时,支持app.use()方式调用,需要对象有一个install方法,use的时候会自动调用install方法将组件进行挂载, 同时页面中用到的全局样式,在这里也可以导入\n关键点3:package.json配置\n官方示例:\n&#123;\n  &quot;name&quot;: &quot;my-lib&quot;,\n  &quot;type&quot;: &quot;module&quot;,\n  &quot;files&quot;: [&quot;dist&quot;],\n  &quot;main&quot;: &quot;.&#x2F;dist&#x2F;my-lib.umd.cjs&quot;,\n  &quot;module&quot;: &quot;.&#x2F;dist&#x2F;my-lib.js&quot;,\n  &quot;exports&quot;: &#123;\n    &quot;.&quot;: &#123;\n      &quot;import&quot;: &quot;.&#x2F;dist&#x2F;my-lib.js&quot;,\n      &quot;require&quot;: &quot;.&#x2F;dist&#x2F;my-lib.umd.cjs&quot;\n    &#125;\n  &#125;\n&#125;\n\n\n我的配置:\n&quot;name&quot;: &quot;protable&quot;,\n&quot;version&quot;: &quot;0.0.9&quot;,\n&quot;type&quot;: &quot;module&quot;,\n&quot;main&quot;: &quot;dist&#x2F;protable.umd.cjs&quot;,\n&quot;module&quot;: &quot;dist&#x2F;protable.js&quot;,\n&quot;files&quot;: [\n  &quot;dist&#x2F;*&quot;\n],\n&quot;license&quot;: &quot;MIT&quot;,\n\n\n\n后面的打包流程就比较统一, npm build + npm login+ npm publish\n","slug":"打包vue组件","date":"2023-11-01T08:42:32.815Z","categories_index":"vue","tags_index":"vue","author_index":"xm"},{"id":"e1121624ccf7ee8269e7ec667bade830","title":"Frist Blog","content":"前端小憩站：起航的第一步代码的魔法舞台嗨，各位码农和前端爱好者！欢迎来到前端小憩站，这是我人生中的第一篇博客，希望和大家一起探索前端开发的无限魅力！\n揭开技术面纱稍等一下，别走开！其实，我在写代码之余还是一个游戏爱好者。我相信，这种多样化的兴趣能够为我的前端旅程增添更多色彩。\n前端的多彩剧场这个博客将会涵盖许多精彩主题：\n\n设计与代码：我将分享我眼中的界面与代码之美，如何将设计融入前端开发。\n交互与创新：一同探讨如何通过前端技术创造出交互丰富的用户体验，解锁无限可能。\n学习与分享：这是一个共同成长的空间，我会分享学习心得和前端小贴士，期待听到你们的声音！\n\n开发，为何如此努力？“为什么要写博客呢？” 或许你有这个疑问。是的，我想和大家分享我的技术经验和探索，同时也是为了从你们那里获得更多灵感。这是一个互利共赢的学习之地，我相信，这里能够汇聚前端开发者的智慧。\n在代码的熔炉中成长在前端小憩站的每一篇博文，都是我与你们一同踏上的技术征程。无论是解谜代码的快感，还是设计与技术碰撞的创新火花，都将在这里发酵，成为我们共同的财富。\n最后一点激励在这里，不仅是技术，还有激情和好奇心。我鼓励你们积极参与，留下你们的足迹和思考。让我们一同创造一个前端开发的小乐园，共同前行！\n感谢你们的支持！\n[XM][2023-08-08]\n","slug":"frist-blog","date":"2023-08-08T06:45:34.829Z","categories_index":"随笔","tags_index":"随笔","author_index":"xm"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-08-07T07:25:45.360Z","categories_index":"","tags_index":"","author_index":"xm"}]